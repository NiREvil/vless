name: ESET Key Generator

permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      account:
        description: 'Number of Accounts to be generated (default = 0)'
        required: false
        default: '0'
      key:
        description: 'Number of Keys to be generated (default = 1)'
        required: false
        default: '1'
      mail:
        description: 'Choose the mail provider to generate license'
        required: true
        type: choice
        options:
        - inboxes
        - 1secmail
        - fakemail
        - mailticking
        - guerrillamail
        - incognitomail
        - developermail
        default: fakemail
      key_type:
        description: 'Operation'
        required: true
        type: choice
        options:
        - --key
        - --vpn-codes
        - --small-business-key
        default: --vpn-codes
      branch:
        description: "Key-Gen Repository branch (default = main)"
        required: false
        default: 'main'
  schedule:
    - cron: '0 */4 * * *'

jobs:
  generate-and-commit:
    runs-on: ubuntu-latest
    env:
      DEFAULT_ACCOUNT: '0'
      DEFAULT_KEY: '1'
      DEFAULT_MAIL: 'fakemail'
      DEFAULT_KEY_TYPE: '--vpn-codes'
      DEFAULT_BRANCH: 'main'
      OUTPUT_FILENAME: 'ESET-CODES.md'
      TEMP_OUTPUT_FILE: 'key_gen_output.log'
      LOG_DIR: 'logs'
      LAST_RUN_DATE_FILE: 'edge/assets/logs/.last_run_date'

    steps:
      - name: Checkout Repository Code
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: |
          mkdir -p "${{ env.LOG_DIR }}"
          echo "Created directory: ${{ env.LOG_DIR }}"

      - name: Generate Keys
        run: |
          ACCOUNT=${{ github.event.inputs.account || env.DEFAULT_ACCOUNT }}
          KEY=${{ github.event.inputs.key || env.DEFAULT_KEY }}
          MAIL=${{ github.event.inputs.mail || env.DEFAULT_MAIL }}
          KEY_TYPE=${{ github.event.inputs.key_type || env.DEFAULT_KEY_TYPE }}
          BRANCH=${{ github.event.inputs.branch || env.DEFAULT_BRANCH }}
          OUTPUT_FILE="${{ env.OUTPUT_FILENAME }}"
          TEMP_OUTPUT="${{ env.TEMP_OUTPUT_FILE }}"
          LAST_RUN_FILE="${{ env.LAST_RUN_DATE_FILE }}" 

          echo "⚙️ Configuration"
          echo "Triggered by: ${{ github.event_name }}"
          echo "Account Count: $ACCOUNT"
          echo "Key Count: $KEY"
          echo "Mail Provider: $MAIL"
          echo "Key Type: $KEY_TYPE"
          echo "Key-Gen Branch: $BRANCH"
          echo "Output File: $OUTPUT_FILE"
          echo "Temp Output File: $TEMP_OUTPUT"
          echo "Last Run Date File: $LAST_RUN_FILE"
          echo "Log Directory: ${{ env.LOG_DIR }}"
          echo "---------------------"

          rm -f "$TEMP_OUTPUT"

          echo "Cloning Key-Gen repository..."
          git clone -b ${BRANCH} https://github.com/rzc0d3r/ESET-KeyGen.git
          cd ESET-KeyGen

          echo "Setting up Python environment..."
          sudo apt-get update -y > /dev/null
          sudo apt-get install -y python3-pip python3-venv > /dev/null
          python3 -m venv venv
          source venv/bin/activate
          pip install -r requirements.txt > /dev/null
          echo "Python environment setup complete."

          echo "Generating accounts/keys and capturing output..."
          if [[ ${ACCOUNT} -ne 0 ]]; then
            echo "Generating $ACCOUNT accounts..."
            python3 main.py --auto-detect-browser --account --email-api ${MAIL} --skip-update-check --no-logo --disable-progress-bar --disable-logging --repeat ${ACCOUNT} | tee "../$TEMP_OUTPUT"
          fi
          if [[ ${KEY} -ne 0 ]]; then
            echo "Generating $KEY keys (type: $KEY_TYPE)..."
            APPEND_FLAG=""
            if [[ -f "../$TEMP_OUTPUT" ]]; then
              APPEND_FLAG="-a"
            fi
            
            python3 main.py --auto-detect-browser ${KEY_TYPE} --email-api ${MAIL} --skip-update-check --no-logo --disable-progress-bar --disable-logging --repeat ${KEY} | tee $APPEND_FLAG "../$TEMP_OUTPUT"
          fi
          echo "Generation commands executed. Output captured in ../$TEMP_OUTPUT"

          cd ..

          # --- Extract values and format Markdown for NEW entry ---
          echo "✨ Extracting data and formatting Markdown for the new entry..."
          VPN_CODES_LIST=$(grep '^VPN Codes:' "$TEMP_OUTPUT" | sed 's/^VPN Codes: //' || true)
          LICENSE_NAME=$(grep '^License Name:' "$TEMP_OUTPUT" | sed 's/^License Name: //' || true)
          LICENSE_KEY=$(grep '^License Key:' "$TEMP_OUTPUT" | sed 's/^License Key: //' || true)
          LICENSE_OUT_DATE=$(grep '^License Out Date:' "$TEMP_OUTPUT" | sed 's/^License Out Date: //' || true)
          ACCOUNT_EMAIL=$(grep '^Account Email:' "$TEMP_OUTPUT" | sed 's/^Account Email: //' || true)
          ACCOUNT_PASSWORD=$(grep '^Account Password:' "$TEMP_OUTPUT" | sed 's/^Account Password: //' || true)

          NEW_ENTRY_FILE="new_entry.md.tmp"
          CURRENT_DATETIME_IRAN=$(TZ='Asia/Tehran' date '+%A, %d %B %Y, %H:%M IRN')

          # Start building the new entry
          {
            echo "## Generated On: ${CURRENT_DATETIME_IRAN}"
            echo ""
            echo "> [!WARNING]"
            echo ">"
            echo "> - Triggered by: **${{ github.event_name }}**"
            echo "> - Time-Sensitive Codes"
            echo "> - Expire in 24 hours"
            echo "> - Single-device binding"
            echo "> - No reactivation permitted <br><br/>"
            echo ""
            echo "<br/>"
            echo ""
          } > "$NEW_ENTRY_FILE"

          # 1. Add VPN Codes Section (if VPN codes exist)
          if [[ -n "$VPN_CODES_LIST" ]]; then
            {
              echo "**ESET VPN ACCESS CODES**"
              echo ""
              echo '```ruby'
              echo "$VPN_CODES_LIST" | sed 's/, /\n/g'
              echo '```'
              echo ""
              echo "<br/>"
              echo ""
            } >> "$NEW_ENTRY_FILE"
          fi

          # 2. Add ESET Security License Section (if License Key exists)
          if [[ -n "$LICENSE_KEY" ]]; then
            {
              echo "**ESET BUSINESS SECURITY LICENSE**"
              echo ""
              echo '```yml'
              echo "Expiry: ${LICENSE_OUT_DATE:-N/A}"
              echo "License Key: ${LICENSE_KEY}"
              echo '```'
              echo ""
              echo "<br/>"
              echo ""
            } >> "$NEW_ENTRY_FILE"
          fi

          # 3. Add ESET Account Section (if Account Email exists)
          if [[ -n "$ACCOUNT_EMAIL" ]]; then
            {
              echo "**ESET ACCOUNT Credentials**"
              echo ""
              echo '```yml'
              echo "Email: ${ACCOUNT_EMAIL}"
              if [[ -n "$ACCOUNT_PASSWORD" ]]; then
                echo "Password: $ACCOUNT_PASSWORD"
              else
                echo "Password: N/A"
              fi
              echo '```'
              echo ""
              echo "<br/>"
              echo ""
            } >> "$NEW_ENTRY_FILE"
          fi

          # 4. Add Static Footer Link Section for the entry
          {
            echo "Everything you need to know about ESET. [^1]"
            echo "Need more VPN access codes? [^2]"
            echo ""
            echo "<br/>"
            echo ""
          } >> "$NEW_ENTRY_FILE"
          # --- End of NEW_ENTRY_FILE content generation ---

          echo "Markdown formatting complete for the new entry in $NEW_ENTRY_FILE."

          echo "Determining whether to prepend or overwrite based on date..."
          CURRENT_DATE_UTC=$(date -u +'%Y-%m-%d')
          LAST_RUN_DATE="never"

          if [[ -f "$LAST_RUN_FILE" ]]; then
              LAST_RUN_DATE=$(cat "$LAST_RUN_FILE")
              echo "Last reset/write date found in $LAST_RUN_FILE: $LAST_RUN_DATE"
          else
              echo "$LAST_RUN_FILE not found. Assuming first run or manual deletion."
          fi

          echo "Current UTC date: $CURRENT_DATE_UTC"

          SHOULD_RESET=false
          if [[ "$CURRENT_DATE_UTC" != "$LAST_RUN_DATE" ]] || [[ ! -f "$OUTPUT_FILE" ]]; then
              echo "Reset condition met: New day ($CURRENT_DATE_UTC != $LAST_RUN_DATE) or output file missing."
              SHOULD_RESET=true
          else
              echo "Reset condition not met: Still the same day ($CURRENT_DATE_UTC == $LAST_RUN_DATE) and output file exists."
          fi

          FOOTNOTES="[^1]: [View Full Post](https://t.me/F_NiREvil/2113)\n\n[^2]: [Explore The Darkness Hub](https://t.me/Eset_key_trial)"

          if [[ "$SHOULD_RESET" == "true" ]]; then
              echo "Overwriting ${OUTPUT_FILE} with the new entry and new structure."
              {
                  echo ""
                  echo "#"
                  cat "$NEW_ENTRY_FILE"
                  echo -e "$FOOTNOTES"
              } > "$OUTPUT_FILE"
              echo "Updating $LAST_RUN_FILE with current date: $CURRENT_DATE_UTC"
              echo "$CURRENT_DATE_UTC" > "$LAST_RUN_FILE"
          else
              echo "Prepending the new entry to ${OUTPUT_FILE} and restructuring."
              OLD_CONTENT_BODY_TMP="old_content_body.tmp"
              TEMP_COMBINED_FILE="combined.md.tmp"

              # Safely get the body of the old file:
              # Skip first line (old '#'), and remove last 2 lines (old footnotes)
              # Check if OUTPUT_FILE exists and has more than 3 lines before attempting to strip
              if [[ -f "$OUTPUT_FILE" ]] && [[ $(wc -l < "$OUTPUT_FILE") -gt 3 ]]; then
                  # sed '1d' "$OUTPUT_FILE" | head -n -2 > "$OLD_CONTENT_BODY_TMP"
                  # A more robust way to remove first line and last two lines:
                  # Get total lines, then print from line 2 to line (total - 2)
                  total_lines=$(wc -l < "$OUTPUT_FILE")
                  lines_to_keep=$((total_lines - 1 - 2)) # -1 for first line, -2 for last two
                  if [[ $lines_to_keep -lt 0 ]]; then lines_to_keep=0; fi # handle very short files
                  if [[ $lines_to_keep -gt 0 ]]; then
                      tail -n +2 "$OUTPUT_FILE" | head -n "$lines_to_keep" > "$OLD_CONTENT_BODY_TMP"
                  else
                      # File is too short to contain previous entries in the expected format
                      # (e.g. only header and footnotes, or less)
                      # So, effectively, there's no "old body" to prepend after the new entry.
                      echo "" > "$OLD_CONTENT_BODY_TMP"
                  fi
              else
                  # Output file doesn't exist or is too short, so no old body to preserve.
                  echo "" > "$OLD_CONTENT_BODY_TMP"
              fi

              {
                  echo ""
                  echo "#"
                  cat "$NEW_ENTRY_FILE"
                  # Add separator if there's old content to follow
                  if [[ -s "$OLD_CONTENT_BODY_TMP" ]]; then
                      echo ""
                      echo "#"
                      cat "$OLD_CONTENT_BODY_TMP"
                  fi
                  echo -e "$FOOTNOTES"
              } > "$TEMP_COMBINED_FILE"
              mv "$TEMP_COMBINED_FILE" "$OUTPUT_FILE"
              # rm "$NEW_ENTRY_FILE" # NEW_ENTRY_FILE is temp, remove it
              echo "$LAST_RUN_FILE remains unchanged ($LAST_RUN_DATE)."
          fi

          # Clean up temporary file used for new entry markdown
          if [[ -f "$NEW_ENTRY_FILE" ]]; then
              rm "$NEW_ENTRY_FILE"
          fi
          if [[ -f "old_content_body.tmp" ]]; then
              rm "old_content_body.tmp"
          fi

          # rm -f "$TEMP_OUTPUT"
          echo "File update complete for ${OUTPUT_FILE}."
          echo "Final content of ${OUTPUT_FILE} (first 100 lines):"
          head -n 100 "${OUTPUT_FILE}"


      - name: Commit and Push Generated Keys
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "feat: Update ESET generated Key/License/Accounts (${{ github.event_name }})"
          file_pattern: "${{ env.OUTPUT_FILENAME }} ${{ env.LAST_RUN_DATE_FILE }}"
          commit_user_name: "ESET Security Bot"
          commit_user_email: "pr@eset.com"
          commit_options: '--signoff'
          # push_options: '--force'
          
